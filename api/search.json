[{"id":"1c3e1155bc6ca82325e8a97f2309df25","title":"Redis基础数据结构和命令","content":"\n\n\n\n\n\n\n\n\n本篇文章将介绍Redis的基础数据结构和命令，熟练掌握了Redis的基础知识，才能更好的深入了解Redis的进阶底层原理\n一、Redis基础数据结构Redis 有 5 种基础数据结构，分别为：string (字符串)、list (列表)、set (集合)、hash (哈 希) 和 zset (有序集合)\n1. string 字符串字符串 string 是 Redis 最简单的数据结构。Redis 所有的数据结构都是以唯一的 key 字符串作为名称，然后通过这个唯一 key 值来获取相应的 value 数据。不同类型的数据结构的差异就在于 value 的结构不一样\n\n字符串结构使用非常广泛，一个常见的用途就是缓存用户信息。我们将用户信息结构体使用 JSON 序列化成字符串，然后将序列化后的字符串塞进 Redis 来缓存。同样，取用户信息会经过一次反序列化的过程。\n\nRedis 的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配，如图中所示，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。\n设置和读取键值对命令# 添加单个 redis 键值对\nset [key] [value]\n\n# 获取单个 redis key 对应的值\nget [key]\n\n# 删除单个 redis 键值对\ndel [key]\n\n# 批量添加键值对\nmset [key1] [value1] [key2] [value2] [key3] [value3]\n\n# 批量获取 value\nmget [key1] [key2] [key3]\n\n过期和 set 命令拓展可以对 key 设置过期时间，到点自动删除，这个功能常用来控制缓存的失效时间\n# 设置键值对过期时间\nset [key] [value]\nexpire [key] [过期秒数]\n\n# 设置键值对同时设置过期时间 等价于 set + expire\nsetex [key] [过期秒数] [value]\n\n# 如果 key 不存在，则新建，否则不处理，直接使用 set 会覆盖原值\nsetnx [key] [value]\n\n计数如果 value 值是一个整数，还可以对它进行自增操作。自增是有范围的，它的范围是 signed long 的最大最小值，超过了这个值，Redis 会报错\n# 不指定增加长度则默认自增1\nset [key] 30\n\nincr [key]\n&gt; 31\n\n# 指定增加长度\nincrby [key] 5\n&gt; 36\n\nincrby [key] -5\n&gt; 31\n\n# Long.Max\nset [key] 9223372036854775807\nincrby [key] 5\n&gt; (error) ERR increment or decrement would overflow \n\n\n2. list 列表Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 *O(1)*，但是索引定位很慢，时间复杂度为 O(n)\n当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收\nRedis 的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理\n# 添加列表元素，其中push命令可以使用 lpush 和 rpush ，l代表在列表开头添加新元素，r代表在列表末尾添加新元素\nlpush list 1 2 3 4 5 6\n&gt; [6,5,4,3,2,1]\nrpush list 1 2 3 4 5 6\n&gt; [1,2,3,4,5,6]\n\n# 查询列表长度\nllen list\n&gt; (integer) 6\n\n# 弹出列表元素，和 push 类似，可以有 lpop 和 rpop ，组合使用达到不同的集合效果\nlist:[1,2,3,4,5,6]\n\nlpop list\n&gt; 1\nrpop list\n&gt; 6\n\n\nlindex 相当于 Java 链表的 get(int index) 方法，它需要对链表进行遍历，性能随着参数 index 增大而变差。 ltrim 和字面上的含义不太一样，个人觉得它叫 lretain(保留) 更合适一些，因为 ltrim 跟的两个参数 start_index 和 end_index 定义了一个区间，在这个区间内的值，ltrim 要保留，区间之外统统砍掉。我们可以通过 ltrim 来实现一个定长的链表，这一点非常有用。index 可以为负数，index=-1 表示倒数第一个元素，同样 index=-2 表示倒数第二个元素。\n# lindex 根据索引获取值\nlist:[1,2,3,4,5,6]\n\nlindex list 1\n&gt; (integer) 2\n\n# ltrim 只保留区间索引的值\nltrim list 1 -1 \n&gt; list:[2,3,4,5,6] \n\n# lrange 输出区间索引的值\nlrange list 3 -1\n&gt; list: [4,5,6]\n\n快速列表\n如果再深入一点，你会发现 Redis 底层存储的还不是一个简单的 linkedlist，而是称之为快速链表 quicklist 的一个结构。首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成 quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间，而且会加重内存的碎片化。比如这个列表里存的只是 int 类型的数据，结构上还需要两个额外指针 prev 和 next 。所以 Redis 将链表和 ziplist 结合起来组成了 quicklist。也就是将多个 ziplist 使用双向指针串起来使用。这样既满足了快的插入删除性能，又不会出现太大的空间冗余。\n3. hash字典Redis 的字典相当于 Java 语言里面的 HashMap，它是无序字典。内部实现结构上同 Java 的 HashMap 也是一致的，同样的数组 + 链表二维结构。第一维 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。\n\n不同的是，Redis 的字典的值只能是字符串，另外它们 rehash 的方式不一样，因为 Java 的 HashMap 在字典很大时，rehash 是个耗时的操作，需要一次性全部 rehash。Redis 为了高性能，不能堵塞服务，所以采用了渐进式 rehash 策略。\n\n渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，查询时会同时查询两个 hash 结构，然后在后续的定时任务中以及 hash 的子指令中，循序渐进地将旧 hash 的内容一点点迁移到新的 hash 结构中。\n\n当 hash 移除了最后一个元素之后，该数据结构自动被删除，内存被回收。hash 结构也可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象，hash 可以对用户结构中的每个字段单独存储。这样当我们需要获取用户信息时可以进行部分获取。而以整个字符串的形式去保存用户信息的话就只能一次性全部读取，这样就会比较浪费网络流量。\nhash 也有缺点，hash 结构的存储消耗要高于单个字符串，到底该使用 hash 还是字符串，需要根据实际情况再三权衡。\n\n# 创建 hash 表\nhset hashmap [key] [value]\n\n# 获取 hash 表的值\nhget hashmap [key]\n\n# 批量创建 hash 表键值对\nhmset hashmap [key1] [value1] [key2] [value2] [key2] [value2]\n\n# 批量获取 hash 表键值对\nhmget hashmap [key1] [key2] [key3]\n\n# 获取 hash 表的所有key\nhkeys hashmap\n\n# 获取 hash 表所有键值对，key 和 value 依次输出\nhgetall hashmap\n\n# 获取 hash 表的键值对长度\nhlen hashmap\n\n\n同字符串一样，hash 结构中的单个子 key 也可以进行计数，它对应的指令是 hincrby， 和 incr 使用基本一样\n# 给 hash 表中数字的值做增减\nage : 18\n\nhincrby hashmap age 5\n&gt; (integer) 23\n\n4. set 集合Redis 的集合相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。 set 结构可以用来存储活动中奖的用户 ID，因为有去重功能，可以保证同一个用户不会中奖两次。\n# 添加元素\nsadd hashset &lt;value&gt;\n&gt; (integer) 1\n# 添加重复元素\nsadd hashset &lt;value&gt;\n&gt; (integer) 0\n# 批量添加元素和单个是一样的命令\nsadd hashset &lt;value1&gt; &lt;value2&gt; &lt;value3&gt;...\n\n# 查询 set 的所有值 该集合是无序的\nsmembers hashset\n\n# 判断 set 中是否存在该值\nsismember hashset &lt;value&gt;\n&gt; (integer) 1\n\n# 获取 set 长度\nscard hashset\n&gt; (integer) 1\n\n# 取出一个元素 （无序）\nspop hashset\n&gt; &lt;value&gt;\n\n\n5. 有序列表 zsetzset 可能是 Redis 提供的最为特色的数据结构，它也是在面试中面试官最爱问的数据结构。它类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。它的内部实现用的是一种叫着「跳跃列表」的数据结构。zset 中最后一个 value 被移除后，数据结构自动删除，内存被回收。 zset 可以用来存粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间进行排序。zset 还可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次。\n# 添加有序列表元素\nzadd sortmap &lt;score&gt; &lt;value&gt;\nzadd sortmap 8.1 &quot;I love Java&quot;\nzadd sortmap 7.1 &quot;I love Python&quot;\nzadd sortmap 6.1 &quot;I love Php&quot;\n\n# 列出索引区间的元素,按 score 升序列出，参数区间为排名范围\nzrange sortmap 0 -1  \n&gt; &quot;I love Php&quot;\n&gt; &quot;I love Python&quot;\n&gt; &quot;I love Java&quot;\n\n# 逆序列出索引区间的元素,按 score 降序列出，参数区间为排名范围\nzrevrange sortmap 0 -1\n&gt; &quot;I love Java&quot;\n&gt; &quot;I love Python&quot;\n&gt; &quot;I love Php&quot;\n\n# 输出集合长度\nzcard sortmap\n&gt; (integet) 3\n\n# 获取指定 value 值的 score\nzscore &quot;I love Python&quot;\n&gt; 7.0999999999999996  # double 会有精度问题\n\n# 根据 score 区间分值获取元素\nzrangebyscore sortmap 0 8\n&gt; &quot;I love Python&quot;   \n&gt; &quot;I love Php&quot;\n\n# 删除 value\nzrem sortmap &quot;I love Java&quot;\n\n跳跃列表zset 内部的排序功能是通过「跳跃列表」数据结构来实现的，它的结构非常特殊，也比较复杂。因为 zset 要支持随机的插入和删除，所以它不好使用数组来表示。我们先看一个普通的链表结构。\n\n我们需要这个链表按照 score 值进行排序。这意味着当有新元素需要插入时，要定位到特定位置的插入点，这样才可以继续保证链表是有序的。通常我们会通过二分查找来找到插入点，但是二分查找的对象必须是数组，只有数组才可以支持快速位置定位，链表做不到，那该怎么办？\n想想一个创业公司，刚开始只有几个人，团队成员之间人人平等，都是联合创始人。随着公司的成长，人数渐渐变多，团队沟通成本随之增加。这时候就会引入组长制，对团队进行划分。每个团队会有一个组长。开会的时候分团队进行，多个组长之间还会有自己的会议安排。公司规模进一步扩展，需要再增加一个层级 —— 部门，每个部门会从组长列表中推选出一个代表来作为部长。部长们之间还会有自己的高层会议安排。跳跃列表就是类似于这种层级制，最下面一层所有的元素都会串起来。然后每隔几个元素挑选出一个代表来，再将这几个代表使用另外一级指针串起来。然后在这些代表里再挑出二级代表，再串起来。最终就形成了金字塔结构。 想想你老家在世界地图中的位置：亚洲- -&gt;中国-&gt;安徽省-&gt;安庆市-&gt;枞阳县-&gt;汤沟镇-&gt;田间村-&gt;xxxx 号，也是这样一个类似的结构。\n\n「跳跃列表」之所以「跳跃」，是因为内部的元素可能「身兼数职」，比如上图中间的这个元素，同时处于 L0、L1 和 L2 层，可以快速在不同层次之间进行「跳跃」。定位插入点时，先在顶层进行定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插进去。你也许会问，那新插入的元素如何才有机会「身兼数职」呢？跳跃列表采取一个随机策略来决定新元素可以兼职到第几层。首先 L0 层肯定是 100% 了，L1 层只有 50% 的概率，L2 层只有 25% 的概率，L3 层只有 12.5% 的概率，一直随机到最顶层 L31 层。绝大多数元素都过不了几层，只有极少数元素可以深入到顶层。列表中的元素越多，能够深入的层次就越深，能进入到顶层的概率就会越大。\n二、 容器型数据结构的通用规则list/set/hash/zset 这四种数据结构是容器型数据结构，它们共享下面两条通用规则：\n1、create if not exists如果容器不存在，那就创建一个，再进行操作。比如 rpush 操作刚开始是没有列表的，Redis 就会自动创建一个，然后再 rpush 进去新元素。\n2、drop if no elements如果容器里元素没有了，那么立即删除元素，释放内存。这意味着 lpop 操作到最后一个元素，列表就消失了。过期时间 Redis 所有的数据结构都可以设置过期时间，时间到了，Redis 会自动删除相应的对象。需要注意的是过期是以对象为单位，比如一个 hash 结构的过期是整个 hash 对象的过期，而不是其中的某个子 key。还有一个需要特别注意的地方是如果一个字符串已经设置了过期时间，然后你调用了 set 方法修改了它，它的过期时间会消失。\nset codehole yoyo \n&gt; OK \nexpire codehole 600 \n&gt; (integer) 1 \nttl codehole \n&gt; (integer) 597 \nset codehole yoyo \n&gt; OK \nttl codehole \n&gt; (integer) -1\n\n\n\n\n\n\n\n\n\n\n\n\n部分内容摘录自《Redis深度历险：核心原理和应用实践》这本书，有兴趣的朋友可以阅读这本书了解更多关于 Redis 的知识\n","slug":"Redis基础数据结构和命令","date":"2023-08-21T08:21:04.000Z","categories_index":"","tags_index":"Redis","author_index":"Mins"},{"id":"924e7fa1333bf7d72633305ec8d70397","title":"Java位运算","content":"\n\n\n\n\n\n\n\n\n在刷 leetcode 题目的时候，有部分题目的解题方法都用到了位运算来解决二进制或者部分数学题目，能够减少部分题目的运行时间，但因为平时用的比较少，也没有深入了解过，本篇文章将记录 Java 位运算的知识点，同时不断更新位运算的运用场景，用好位运算在某些场景能够减少许多逻辑计算和判断\n一、位运算规则以十进制数为例，Java 数值运算过程中都是先将十进制转换为二进制然后再进行运算，再把二进制数据转换为十进制展现给用户。二进制运算规则如下：\n对于有符号的而言，\n\n最高位为符号位，0表示正数，1表示负数\n正数的原码，反码和补码都一样\n负数的反码：符号位保持不限，其他位取反\n负数的补码：反码 + 1\n0的反码和补码都是0\n计算机的运算的时候，都是将原码转成补码进行运算的\n\n以32位的负数 int 为例，以下为转码规则\n\n博主自己写了个int数据类型的转码方法，可以自己运行看看二进制的结果\n/**\n     * 打印原码\n     */\n    public void original(int num) &#123;\n        //正数处理逻辑\n        if (num >= 0) &#123;\n            for (int i = 31; i >= 0; i--) &#123;\n                System.out.print((num &amp; (1 &lt;&lt; i)) == 0 ? \"0\" : \"1\");\n            &#125;\n        &#125; \n      \t//负数除符号位，其余位置跟他的相反数一致\n        else &#123;\n            System.out.print(\"1\");\n            num = -num;\n            for (int i = 30; i >= 0; i--) &#123;\n                System.out.print((num &amp; (1 &lt;&lt; i)) == 0 ? \"0\" : \"1\");\n            &#125;\n        &#125;\n        System.out.println();\n    &#125;\n\n    /**\n     * 打印反码\n     */\n    public void reverse(int num) &#123;\n        //正数反码与原码一致\n        if (num >= 0)\n            original(num);\n        else &#123;\n            System.out.print(\"1\"); //打印负数符号位\n            num = -num;\n            for (int i = 30; i >= 0; i--) &#123;\n                System.out.print((num &amp; (1 &lt;&lt; i)) == 0 ? \"1\" : \"0\");\n            &#125;\n            System.out.println();\n        &#125;\n    &#125;\n\n    /**\n     * 打印补码\n     */\n    public void repair(int num) &#123;\n        if (num >= 0)\n            original(num);\n        else &#123;\n            StringBuilder sb = new StringBuilder();\n            int isAdd = 1; //补码加1\n            num = -num;\n            for (int i = 0; i &lt; 31; i++) &#123;\n                int tempNum = ((num &amp; (1 &lt;&lt; i)) == 0) ? 1 : 0;\n                int sum = tempNum + isAdd;\n                if (sum > 1) &#123;\n                    tempNum = 0;\n                    isAdd = 1;\n                &#125; else &#123;\n                    tempNum = sum;\n                    isAdd = 0;\n                &#125;\n                sb.append(tempNum);\n            &#125;\n            sb.append(1); //负数符号位\n            System.out.println(sb.reverse().toString());\n        &#125;\n    &#125;\n\n\n\n\n\n二、Java 支持的位运算符\n与（&amp;）：二元运算符，两个为1时结果为1，否则为0\n或（|）：二元运算符，两个其中有一个为1时结果就为1，否则为0\n异或（^）：二元运算符，两个数同时为1或0时结果为1，否则为0\n取非（~）：一元运算符，取反操作\n左移（&lt;&lt;）：一元运算符，按位左移一定的位置。高位溢出，低位补符号位，符号位不变。\n右移（&gt;&gt;）：一元运算符，按位右移一定的位置。高位补符号位，符号位不变，低位溢出。\n无符号右移（&gt;&gt;&gt;）：一元运算符，符号位（即最高位）保留，其它位置向右移动，高位补零，低位溢出\n\n\n三、逻辑运算1. 与运算\n\n\n\n\n\n\n\n\n运算规则\n两个数字相同位置的 bit 进行对位运算，若两个值都是1，则等于1，否则等于0\n\n\n\n\n\n\n\n\n\n\n运算过程\n以 1 &amp; -5 = 0为例子展示运算流程：\n\n因为1为正数，所以原码和补码相同，即1的补码为：00000000 0000000 00000000 00000001\n\n\n因为-5为负数，所以需要进行原码 &gt;&gt;&gt; 反码 &gt;&gt;&gt; 补码的转换\n\n原码：10000000 00000000 00000000 00000101\n反码：11111111 11111111 11111111 11111010\n补码：11111111 11111111 11111111 11111011\n\n&amp; 运算：  \n\n00000000 0000000 00000000 00000001\n1111111 11111111 11111111 11111011         \n00000000 00000000 00000000 00000001\n\n得到的补码结果为：00000000 00000000 00000000 0000001 所以结果为1\n\n2. 或运算\n\n\n\n\n\n\n\n\n 运算规则\n两个数字相同位置的 bit 进行对位运算，其中一个值为1，都等于1，否则等于0\n\n\n\n\n\n\n\n\n\n\n运算过程\n以 -2 | 5 = -1为例展示运算流程：\n\n-2为负数，需要进行原码 &gt; 反码 &gt; 补码的转换。转换步骤如下：　\n\n原码：10000000 00000000 00000000 00000010\\\n符号位不变，其他位置取反得反码：11111111 11111111 11111111 11111101\n在反码的基础上＋1得到补码： 11111111 11111111 11111111 11111110\n\n5为正数，补码和反码一致，所以5的补码为：00000000 00000000 00000000 00000101\n将-2 和 5 的补码进行或运算\n\n11111111 11111111 11111111 11111110\n00000000 00000000 00000000 00000101 \n11111111 11111111 11111111 11111111\n\n根据上面的运算得到补码结果为：11111111 11111111 11111111 11111111\n\n结果显然是一个负数，而负数的补码和原码不一致，所以需要将补码结果转换为原码才能得到最终的结果\n\n补码转原码的过程是跟原码转补码相反的过程，具体过程如下：\n\n\n补码：11111111 11111111 11111111 11111111\n补码 -1 得到反码：11111111 11111111 11111111 11111110\n符号位不变，其他位置取反得：10000000 00000000 00000000 00000001\n\n最终得到的原码结果为 10000000 00000000 00000000 00000001，转成十进制为 -1\n\n3. 异或\n\n\n\n\n\n\n\n\n运算规则\n两个数相同位置的 bit 进行或运算，若两个数均为0或1，则等于0，否则等于1\n\n\n\n\n\n\n\n\n\n\n运算过程\n以 1 ^ -5 = 6 为例，具体运算流程如下：\n\n1的补码为：00000000 00000000 00000000 00000001\n\n-5的补码为：11111111 11111111 11111111 11111011（可参考与运算给出的流程）\n\n两个补码运算：　　\n\n\n00000000   00000000   00000000    00000001\n11111111   11111111   11111111    11111011\n11111111   11111111  11111111     11111010\n\n得到的补码结果为：11111111   11111111  11111111   11111010\n\n补码为负数，需要转换成原码：\n\n\n补码：11111111   11111111  11111111   11111010\n反码：11111111   11111111  11111111   11111001\n原码：10000000   00000000  00000000   00000110\n\n由原码：10000000 00000000 00000000 000000110，得出最终的时间结果为 -6.\n\n4. 非\n\n\n\n\n\n\n\n\n运算规则\n若位数为0，则取反后为1，若为1，取反后为0\n\n\n\n\n\n\n\n\n\n\n运算过程\n以~2 = -3为例运算流程如下：\n\n2的原码为：00000000 00000000 00000000 00000010\n\n2的补码跟原码一致也为：00000000 00000000 00000000 00000010\n\n取反：111111111 11111111 11111111 11111101\n\n取反后的结果仍未补码，此时补码为负数，则需要转成原码\n\n11111111 11111111 11111111 11111101 减 1 得到反码：11111111 11111111 11111111 11111100\n\n11111111 11111111 11111111 11111100 符号位不变，其他位置取反得到原码为：10000000 00000000 00000000 00000011\n\n10000000 00000000 00000000 00000011 转成十进制结果为 -3\n\n\n5. 左移\n\n\n\n\n\n\n\n\n运算规则\n符号位不变，高位溢出截断，低位补零。比如 -1 &lt;&lt; 2 = -4 (为方便讲解，图示的补码为-1)\n\n6. 右移\n\n\n\n\n\n\n\n\n运算规则\n符号位不变，低位溢出截断，高位用符号位填充。如：8 &gt;&gt; 2 = 2\n\n7. 无符号右移\n\n\n\n\n\n\n\n\n运算规则\n高位填充0，低位溢出。如-1&gt;&gt;&gt;1=2147483647\n\n\n四、应用场景1. 二进制奇偶判断操作例如一个数 &amp; 1的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数为偶数，最末位为1表示该数为奇数。\n\n2. 左移位实现2的幂次方例如2的4次方，可以利用左移4位达到目的，2&lt;&lt;4等于32，符号位不变，可以看到1的位置左移以后，后面补了4个0，转成十进制等于32\n\n\n\n\n\n\n\n\n\n\n数值value向左移动num位，左边二进制位丢弃，右边补0。（注意byte和short类型移位运算时会变成int型，结果要强制转换）\n\n若1被移位到最左侧，则变成负数\n\n左移时舍弃位不包含1，则左移一次，相当于乘2。\n\n\n\n3. 右移位实现根号2例如32右移4位，符号位不变，可以看到1的位置右移以后，前面补了4个0，转成十进制等于2\n\n\n\n\n\n\n\n\n\n\n数值value向右移动num位，正数左补0，负数左补1，右边舍弃。（即保留符号位）\n\n右移一次，相当于除以2，并舍弃余数。\n\n无符号右移&gt;&gt;&gt;：左边位用0补充，右边丢弃。\n\n\n\n4. 异或相同的数等于它本身例如力扣题目 136. 只出现一次的数字，在数组[4,1,2,1,2]中寻找只出现一次的数字4，正常解法是借助map之类的数据结构计数，找到出现次数为1的数字，但复杂度为O(n)，使用异或运算将大幅降低时间和空间的复杂度.\nif (nums.length &lt; 1)\n   return 0;\n\nint res = nums[0];\nfor (int i = 1; i &lt; nums.length; i++) &#123;\n    res = nums[i] ^ res;\n&#125;\n\nreturn res;\n\n\n部分内容来源博文: Java 位运算详解\n","slug":"Java位运算","date":"2022-09-20T04:21:50.000Z","categories_index":"","tags_index":"Java,位运算,二进制","author_index":"Mins"},{"id":"52853fe0be6fcca34138515b6234395e","title":"Github Pages+Hexo个人博客协作","content":"下面将分享多设备之间进行个人博客维护的步骤，能够随时随地都能在不同的终端里面完成协作\n1. 创建协作分支由于 hexo  通过命令部署到 github 仓库的文件均为静态网页文件，仅用于 github pages 的展示，因此上传的分支是不包括配置文件上传的，需要重新创建一个新的分支，用于元数据的上传。\n\n在 github 的博客仓库创建新的分支\n\ngit checkout -b 分支名称 #创建并切换至对应的分支\n\n\n创建完分支后，把整个分支的代码都拉到本地里面\n\ngit clone -b &lt;分支名称&gt; &lt;仓库地址&gt;\n\n\n2. 生成协作项目创建好分支以后，需要把原本在本地的 hexo 项目的配置文件复制到创建好的 git 项目中，并对 hexo 项目进行初始化\n\n复制本地项目的配置文件\n\n下面是需要复制的文件结构\n. # Hexo 项目根目录.\n├─ _config.yml # Hexo 配置文件.\n├─ _config.aurora.yml # Hexo Aurora 主题配置文件\n├─ package.json # npm 已安装目录文件\n├─ _source # 文章等静态资源\n├─ scaffolds # 模版文件\n└─ _config.aurora.yml # 主题配置.\n\n\n复制完成后，安装所需要的插件\n\nnpm install\n\n\n安装完插件以后，即可使用 hexo 的命令对项目进行初始化\n\nhexo cl &amp; hexo g\n\n\n初始化完成后即可按照正常的 git 项目进行代码协作了\n\ngit add . \ngit commit - m &quot;first commit&quot;\ngit push origin &lt;分支名称&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n搭建完成后，原来本地的项目可以删除了，只需要使用新建的项目进行 hexo 的初始化，以及 git 代码上传即可，这样就可以实现在不同设备间进行协作\n3. 博客协作搭建完成以后，协作就很简单了，只需简单的操作 git 命令，即可无缝衔接博客维护\ngit clone -b &lt;分支名称&gt; &lt;仓库地址&gt;\n\n克隆完项目以后即可继续维护博客了\n","slug":"Github-Pages-Hexo个人博客协作","date":"2022-08-24T08:31:09.000Z","categories_index":"","tags_index":"Hexo,Github Pages","author_index":"Mins"},{"id":"25aedc3dbb7bb7b3e9ea75d87387e23e","title":"MarkDown 语法","content":"MD 语法总结MD即为MarkDown，MarkDown能够使文章更具有可读性，MarkDown的底层实际上是把内容转化为HTML的富文本展示格式，使文章的内容更加具有层次，结构更加清晰。\n1. 标题# H1\n## H2\n### H3\n#### H4\n##### H5\n###### H6\n\n（注意:#号和文字间至少得有一个空格）\n\n同时H1和H2还有另一种写法\n\nH1\n=====\nH2\n-------\n（注意：这里 \"=\" 和 \"-\" 的个数也至少有一个，但要紧随文字下一行）\n\n\n\n\n\n\n\n\n\n\n显示效果\nH1H2H3H4H5H6H1H2\n2. 列表2.1 无序列表无序列表使用星号、加号或是减号（* +  -）作为列表标记\n> 加号\n+ a\n+ b\n+ c\n\n> 减号\n- d\n- e \n- f\n\n> 星号\n* g\n* h\n* i\n\n\n\n\n\n\n\n\n\n\n显示效果\n\na\nb\nc\n\n\nd\ne \nf\n\n\ng\nh\ni\n\n2.2 有序列表有序列表则使用数字接着一个英文句点\n> 有序\n1. abc\n2. bcd\n3. cde\n\n\n\n\n\n\n\n\n\n\n显示效果\n\nabc\nbcd\ncde\n\n2.3 组合使用有序列表与无序列表结合\n> 组合使用\n+ 第一章\n\t+ 1\n\t+ 2\n\t+ 3\n+ 第二章\n+ 第三章\n\n> 有序列表嵌套无序列表\n1. 第一章\n\t1. 1\n\t2. 2\n\t3. 3\n2. 第二章\n\t- a\n\t- b\n3. 第三章\n\n\n\n\n\n\n\n\n\n\n显示效果\n\n第一章\n\n1\n\n\n2\n3\n\n\n第二章\n\n第三章\n\n\n\n第一章\n\n1\n2\n3\n\n\n第二章\n\na\nb\n\n\n第三章\n\n第四章\n\n\n\n3. 文本强调Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em&gt; 标签包围，用两个 * 或 _包起来的话，则会被转成 &lt;strong&gt;\n*斜体* _强调_\n**加粗** __加粗__\n***粗斜体*** ___粗斜体___\n~~删除线~~\n\n\n\n\n\n\n\n\n\n\n显示效果\n斜体 强调加粗 加粗粗斜体 粗斜体删除线\n\n4. 代码及区块说明大于号（&gt;），区块说明\n反引号包围（` ），单行代码块\n三个反引号（```+语言），代码块\n> 区块说明\n>> 嵌套\n\n`代码块`\n​``` java\n代码块\n​```\n\n\n\n\n\n\n\n\n\n\n显示效果\n\n\n\n\n\n\n\n\n\n区块说明\n\n嵌套\n\n &lt;html&gt; java &lt;/html&gt;\npublic class Test&#123;\n  public static void main(String[] args)&#123;\n     System.out.println(\"Test\");\n  &#125;\n&#125;\n\n\n5. 链接及图片引用Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。不管是哪一种，链接文字都是用 [方括号] 来标记。\n5.1 行内式只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可\n[百度地址](https://www.baidu.com \"鼠标指向显示描述\")\n显示地址: &lt;https://www.baidu.com>\n\n\n\n\n\n\n\n\n\n\n显示效果\n百度地址\n显示地址: https://www.baidu.com\n5.2 参考式在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记\n[百度首页][id]\n[id]:https://www.baidu.com\n\n\n\n\n\n\n\n\n\n\n显示效果\n百度首页\n\n6. 图片同样分为行内式和参考式\n6.1 行内式和链接的形式差不多，图片的名字放在[]中，图片地址放在随后的()中，title属性（图片地址后面空一格，然后用引号引起来）,注意的是[]前要加上!\n![baidu](https://www.baidu.com/img/baidu_resultlogo@2.png \"url\")\n\n\n\n\n\n\n\n\n\n\n显示效果\n\n6.2 参考式图片的文字放在[]中，图片地址放在随后的:后，title属性（图片地址后面空一格，然后用引号引起来）,注意引用图片的时候在[]前要加上!\n![baidu][logo]\n[logo]: https://www.baidu.com/img/baidu_resultlogo@2.png \"url\"\n\n\n\n\n\n\n\n\n\n\n显示效果\n\n\n7. 分割线分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以\n---\n- - -\n------\n***\n* * *\n******\n___\n_ _ _\n______\n\n\n\n\n\n\n\n\n\n\n 显示效果\n\n\n\n\n\n\n8. 表格用竖线 |  展示表格，用:的不同位置来改变对齐方式，默认左对齐(:-)，右对齐(-:)，居中对齐(:-:)\n|Head1|Head2|Head3|\n|:-|:-:|-:|\n|abc|bcd|cde|\n|123|234|345|\n|123|234|345|\n|123|234|345|\n|123|234|345|\n|123|234|345|\n\n\n\n\n\n\n\n\n\n\n显示效果\n\n\n\nHead1\nHead2\nHead3\n\n\n\nabc\nbcd\ncde\n\n\n123\n234\n345\n\n\n123\n234\n345\n\n\n123\n234\n345\n\n\n123\n234\n345\n\n\n123\n234\n345\n\n\n9. 目录目录先用中括号 [ ] 显示目录名称，再用小括号 ( ) 保存跳转的id，小括号中 # 号表示 id，和 html 的 id 是一个意思\n#### 目录\n[第一章](#1)\n&lt;h4 id='1'>跳转标题&lt;/h4>\n\n\n\n\n\n\n\n\n\n\n显示效果\n目录第一章\n非跳转标题非跳转标题非跳转标题跳转标题\n\n\n\n\n","slug":"MarkDown-语法","date":"2022-08-16T10:01:40.000Z","categories_index":"","tags_index":"MarkDown,MD","author_index":"Mins"},{"id":"cc25b2c3a520c09e3610684adbe1fa97","title":"Github Pages + Hexo 个人博客搭建分享","content":"本文将给大家分享个人博客搭建的详细步骤，以及搭建过程中踩到的坑，希望能够帮助大家快速搭建自己的博客，能够记录开发过程中遇到的问题和总结出的经验。\n博主选的是 Github Pages + Hexo + Aurora主题，如果是自己有时间和兴趣去写动态网页的博客，需要自己购买服务器和域名比较麻烦，还是比较推荐直接用现成静态网页去做比较好，省时省力也省钱，也能满足绝大部分功能了\n准备工作: Node.js  Git 搭建博客依赖的环境\nHexo Doc: https://hexo.io/zh-cn/docs/\n1.  站点选型\n\n\n\n\n\n\n\n\nGithub Pages\n​        由于Github是国外站点，没有梯子时不时都会抽风，但Github有个好处是申请Github Pages不需要上传自己身份证信息(我就是因为太懒不想上传哈哈)，如果不想折腾，能接受有时候蜗牛一样的访问速度，推荐使用Github Pages。下面是Github Pages的整合步骤。\n\n创建 Github 仓库\n\n\n看网上大部分文章都说仓库名命名如果是 {github用户名}.github.io ，仓库就会自动开启 github pages，仓库名直接用github用户名好像也可以(可以试试)，这样访问github pages的时候域名直接就可以用 {github用户名}.github.io 访问，否则就要在域名后面加上仓库名称才能访问自己的博客\n\n设置 github pages\n\n\n\n如果是用用户名创建了仓库，直接访问上述的域名即可，如果是自己有申请独立域名，可以在下方的 Custom domain设置自定义域名\n\n同时可以选择自己编译后的静态网页部署在哪个分支，可以在 Branch 选项设置分支，以及保存的根目录路径\n\n\n\n\n\n\n\n\n\n\n\nGitee Pages\n​        Gitee Pages 其实和 Github Pages 的区别不大，博主本来也是打算用 Gitee 来搭建的，但是之前没有现成的身份证正反面以及手持身份证的照片，就没选择这种方式。\n\n创建 Gitee 仓库\n\n\n和 Github 一样，以用户名作为仓库的名称，创建一个存放静态网页文件的仓库\n\n开启 Gitee Pages 功能\n\n在 服务 菜单里面开启 Gitee Page 功能，如果之前没有做过实名认证，是需要上传身份证资料的，根据自己的情况选择是不是要上传，不实名认证是无法开启这个功能的\n\n\n2. Hexo\n\n\n\n\n\n\n\n\n安装步骤\nHexo 利用 Node.js 和  NPM 安装比较方便，在安装前需前往 Node.js 官网先安装好环境，同时需要安装 Git\n2.1 npm 安装 Hexo在自己的项目目录里面创建一个文件夹用来保存 Hexo 项目，安装好 Node npm 和 Git 环境后，执行安装命令\nnpm install hexo --save\n\n执行完成后可以执行命令查看版本，执行看到有 hexo-cli 的版本号就说明成功安装了\nhexo -version\n\n安装 hexo git 的插件\n npm install hexo-deployer-git --save\n\n安装 hexo-asset-image 插件，如果不安装此插件，文章引入的图片将无法正常显示\nnpm install hexo-asset-image --save\n\n初始化 hexo 项目，后面上传的文件夹就是初始化后的目录\nhexo init &lt;要创建的目录名称>\n\n进入到刚才创建的项目目录里面,安装所有依赖的包\nnpm install\n\n安装完成后，可以看到目录结构如下图\n\n\n执行以下 hexo 的命令，即可在本地生成静态网页文件并运行\n#清空hexo所有已经生成的静态网页文件，如果修改了 yaml 配置文件一定要先执行此命令清空\nhexo clean \n#也可以简写成\nhexo cl\n\n执行完清理命令后，需要执行生成静态网页文件的命令\n#生成静态网页文件\nhexo generate\n#也可以简写成\nhexo g\n\n生成完成后，可以现在本地运行，运行成功后访问 https://localhost:4000 访问本地博客，也可以指定运行的端口，看自己需求\n#不指定端口运行，默认4000端口启动\nhexo server\n#也可以简写成\nhexo s\n#如果需要指定端口，则执行以下命令\nhexo server -p 8000\n#简写也是可以的\nhexo s -p 8000\n\n2.2 主题安装默认的主题是真的很默认，可以自行到 Hexo 官网的主题库中挑选自己喜欢的主题，我选的是三钻的 Aurora 主题，能用 npm 安装而且有自己的主题文档，十分方便，而且确实很好看，第一眼就被吸引了。\nHexo 主题库: https://hexo.io/themes/\nAurora Doc: https://aurora.tridiamond.tech/zh/guide/\n下面我以 Aurora 为例安装主题，可能有部分主题不支持 npm 安装，需要手动保存文件夹再做处理，具体可以根据选择的主题文档完成安装操作\n\n在控制台中，进入 Hexo 项目的根目录，执行主题安装命令\n\nnpm install hexo-theme-aurora --save\n\n\n因为主题是使用 NPM 或者 Yarn 安装的，而不是 clone 到 themes 文件夹的。所以我们需要自己创建一个配置文件。你只需要在 Hexo 博客的根目录下创建一个 _config.aurora.yml 配置文件来配置主题\n\n#命令 windows powershell 不支持，需自行在 下面的路径中找到文件后直接复制\ncp -rf ./node_modules/hexo-theme-aurora/_config.yml ./_config.aurora.yml\n\n\n设置 permalink\n\n因为使用了 Vue-router，Hexo 默认生成的页面和文章的 permalink 与我们 Vue router 中的 path 是不相符的，那么就会出现无法访问的问题。所以我们需要修改 Hexo 默认配置文件里面的 permalink 参数。\n\n打开 Hexo 根目录下的 _config.yml\n\n修改 permalink 参数为  /post/:title.html\nurl: https://tridiamond.tech\npermalink: /post/:title.html #更改这个参数\npermalink_defaults:\npretty_urls:\n  trailing_index: true # Set to false to remove trailing 'index.html' from permalinks\n  trailing_html: true # Set to false to remove trailing '.html' from permalinks\n设置代码高亮\n\n\n最后主题是使用 Prismjs 来实现代码高亮显示，但 Hexo 默认是使用 highlightjs，因此你需要更改 Hexo 配置来使用 Prismjs\n\n把 highlight 的启用改为false\n\n把 prismjs 的启用改为true\n\n把 prismjs 下的 preprocess 改为 false\n\n\nhighlight:\n  enable: false #第一步\n  line_number: true\n  auto_detect: false\n  tab_replace: ''\n  wrap: true\n  hljs: false\nprismjs:\n  enable: true #第二部\n  preprocess: true #第三部\n  line_number: true\n  tab_replace: ''\n\n\n_config.yaml 修改主题配置\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: Aurora #改成 Aurora 主题\n\n2.3 创建 “About” 页面主题默认开启了 about 页面，所以我们需要创建这个 about 页，要不主题就无法正常显示 about 页。\n要创建这个默认的 about 页，文档里面写的那个命令执行不了，不知道是不是版本问题，执行下面这个 Hexo 的命令：\nhexo create page about #主题文档写的这个我执行不了，提示无此命令\n\nhexo new page about #执行这个，新建页面布局about\n\n执行完毕后，你会发现在 source/ 文件中多处了一个新的文件夹：\n.\n└── source\n    └── about\n        └── index.md\n\n你可以随意修改这个 index.md markdown 文件中的内容，此文件的内容将会现在在我们的 about 页面中。\n\n由于无法执行文档中 create page 的命令，因此还需要多加一步，否则跳转到 About 页面后点击刷新，是会出现访问404的情况(new pages是hexo的命令，上面的命令估计是作者封装的，那几个默认页面的原理应该也是读取的type参数)\n\n找到 _source/about/index.md，在文件头上面增加一个type参数，表示它是一个跳转页面，这样就不会出现刷新404的情况了。\n---\ntitle: 关于\ndate: 2022-08-15 18:28:35\ntype: about #增加这个参数\n---\n\n不增加的效果:\n\n\n增加后的效果:\n\n\n\n\n2.4 重新生成与本地服务器使用以下命令来运行本地环境,改变了任何配置都需要重新生成 Hexo 的静态文件！ \nhexo clean &amp; hexo g &amp; hexo s\n\n当文件都生成完毕之后，就可以通过 https://localhost:4000 访问你的博客了。\n\n3. Github Page 部署配置3.1 配置文件一共有两个配置文件，一个是 Hexo 自身的配置，一个是主题专用的配置。\n. # Hexo 项目根目录.\n├─ _config.yml # Hexo 配置文件.\n└─ _config.aurora.yml # 主题配置.\n\n\n\n\n\n\n\n\n\n\n注意\n大部分主题的功能都是使用主题配置文件的，但是有部分需要用到 Hexo 插件的就需要在 Hexo 的配置中修改。\n3.2 基础配置我们可以使用 主题文件_config.aurora.yml中的site参数来设置我们博客的主要信息和配置。\nsite 配置拥有以下选项：\n\n\n\n选项\n接受类型\n使用说明\n\n\n\nsubtitle\nString\n博客自标题，页面主标题后面会跟随这个标题内容。\n\n\nauthor\nString\n博客作者名字，或者是博客名字。会在 header 的 logo 区域显示，也会在博客简介中显示。\n\n\nnick\nString\n博客子名字，会在 header 的 logo 下方显示。\n\n\ndescription\nString\n会在博客简介中显示，用几句话描述博主相关信息（支持 HTML 标签）\n\n\nlanguage\nen, cn\n配置默认博客语言，en 是英文，cn 是中文。\n\n\nmulti_language\ntrue, false\n开启博客的多语言支持\n\n\nlogo\nString\nLogo 的图片链接 image.\n\n\navatar\nString\n头像的图片链接 image.\n\n\nbeian\nObject\n网站备案信息 (从版本 1.1.0 开始，这个配置拥有两个属性)\n\n\nsite:\n  subtitle: Mins's Blog \n  author: Mins #此参数将显示在左上角的logo\n  nick: blog\t#此参数将显示在左上角的logo\n  avatar: /image/avatar.jpeg\t#显示头像\n  link: https://zmstrongest.github.io #博客首页地址\n  description: 'Think like an artist, code like an artisan.' #显示在头像下方的个人简介\n  language: cn \n  multi_language: true\n  logo: https://img-blog.csdnimg.cn/20210313122054101.png\n  #avatar: https://img-blog.csdnimg.cn/20210313122054101.png\n  beian:\n    number: ''\n    link: ''\n  police_beian:\n    number: ''\n    link: ''\n\n3.3 社交配置这部分用于配置我们的社交链接，这些链接会在我们的简介中显示。\n社交配置会有以下配置项：\n\n\n\n配置项\n说明\n\n\n\ngithub\nGithub 简介页链接.\n\n\ntwitter\nTwitter 个人页链接.\n\n\nstackoverflow\nStackoverflow 个人页链接.\n\n\nweibo\n微博个人页链接.\n\n\nzhihu\n知乎简介页链接.\n\n\ncsdn\nCSDN 简介页链接.\n\n\njuejin\n掘金简介页链接.\n\n\n配置例子：\nsocials:\n  github: https://zmstrongest.github.io\n\n如果上面作者提供的自带博客类型不能满足你的需求，想自定义图标和连接，请自行查看 Aurora 的文档进行配置\n3.4 评论区配置\nGithub OAuth Application 申请\n\n到 https://github.com/settings/applications/new 注册一个OAuth Application，后面的 Gitalk 配置需要用到，Application name 可自定义填写，Homepage URL 填写博客主页地址，Authorization callback URL 填写博客主页地址。\n\n\n\n\n提交后会自动生成一个 ClientID和Client Secret，用于后续的评论区配置\n\n这个主题目前支持两个不同的评论插件。您可以使用enable配置来打开以下一款评论插件。\n\n\n\n\n\n\n\n\n\n提示\n如果你同时打开了两个插件，Gitalk将会优先被使用。博主用的是Gitalk\n\nGitalk\n\n配置属性：\n\n\n\n属性\n描述\n\n\n\nenable\n使用true开启, 使用false关闭\n\n\nautoExpand\n如果设置为true, Github 评论将会自动展开。否者默认会收起。\n\n\nclientID\nclientID 是你 GitHub 的 Oauth APP 中提供的。\n\n\nclientSecret\nclientSecret 是你 GitHub 的 Oauth APP 中提供的。\n\n\nrepo\n仓库名, 比如: https://github.com/auroral-ui/**hexo-theme-aurora-docs**, 名字就是 hexo-theme-Aurora-docs\n\n\nowner\n仓库拥有者的用户名. 比如: auroral-ui\n\n\nadmin\n仓库管理员的用户名，这里可以填写多个管理员。(也用于标记那个评论是博主的)\n\n\nid\n确保唯一性和长度小于 50，如果您使用pathname，请确保长度小于 50 个字符或使用uid代替，这个有更好的兼容性 (如果您之前使用其他主题，谁用 uid 将可能无法显示您之前的评论)\n\n\nlanguage\n使用 en 设置为英文，使用 cn 设置为中文.\n\n\ndistractionFreeMode\n与 Facebook 一样的专注模式，点击评论输入框时会让背景变暗。true 来开启 false 来关闭\n\n\nrecentComment\n是否开启最近评论功能。\n\n\nproxy\nGitHub 授权请求的反向代理\n\n\n\n\n\n\n\n\n\n\n\n注意\n如果你在使用 Gitalk 的时候，出现 403 或者 422 这种报错的话，请根据这里的教程在新窗口打开，自己搭建一个反向代理服务，然后把你建立好的方向代理地址配置给 proxy 即可。\n例子：\ngitalk:\n  enable: true\n  autoExpand: false\n  clientID: '' #你在Github申请的ID\n  clientSecret: '' #你在Github申请的Secret\n  repo: '' #博客仓库的名称\n  owner: 'ZmStrongest' #Github用户名\n  admin: ['ZmStrongest'] #Github用户名\n  id: uid\n  language: cn\n  distractionFreeMode: true\n  recentComment: true\n  #proxy: ''\n\n更多的使用指南请查看 Gitalk 插件的官网。\n配置完成后，在博客评论区里面登录自己的 github 账号，进行评论区初始化即可使用，由于github站点可能访问较慢，可能要梯子先登录初始化一下才可以使用，博主没用梯子一直都是连接超时，初始化以后就不再需要了。\n3.5 机器人配置配置例子直接可以直接复制 Aurora 的文档 进行配置\n3.6 Github 部署配置上面讲完了主题的配置文件，现在还需要对 Hexo 的原始配置文件 _config.yml 进行配置修改\n\n配置好github的ssh以后，复制博客在github的仓库地址，并且根据自身情况创建存储博客静态网页内容的分支进行部署提交\n\n# Deployment\n## Docs: https://hexo.io/docs/one-command-deployment\ndeploy:\n  type: git\n  repo: ''  #github仓库地址\n  branch: master #分支名称\n\n\n配置完成后，可以即可通过hexo命令部署到Github Pages上\n\nhexo deploy \n#或者\nhexo d #简写\n\n访问自己之前配置的博客主页地址即可生效，博客地址 ，到这里 Github Pages + Hexo + Aurora 主题的配置就完成了，后续有自定义的需求可以自行参照 Hexo和Aurora的文档进行个性化设置。\n3.7 文章编写配置完成后，即可开始记录自己的文章了\n你可以执行下列命令来创建一篇新文章或者新的页面。\n$ hexo new [layout] &lt;title&gt;\n\n您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。布局（Layout）\nHexo 有三种默认布局：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。\n\n\n\n布局\n路径\n\n\n\npost\nsource/_posts\n\n\npage\nsource\n\n\ndraft\nsource/_drafts\n\n\n\n文件名称\n\nHexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。\n\n\n\n变量\n描述\n\n\n\n:title\n标题（小写，空格将会被替换为短杠）\n\n\n:year\n建立的年份，比如， 2015\n\n\n:month\n建立的月份（有前导零），比如， 04\n\n\n:i_month\n建立的月份（无前导零），比如， 4\n\n\n:day\n建立的日期（有前导零），比如， 07\n\n\n:i_day\n建立的日期（无前导零），比如， 7\n\n\n\n草稿\n\n刚刚提到了 Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source/_drafts 文件夹，您可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。\n$ hexo publish [layout] &lt;title&gt;\n\n草稿默认不会显示在页面中，您可在执行时加上 --draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。\n","slug":"Github-Pages-Hexo-个人博客搭建分享","date":"2022-08-16T09:11:11.000Z","categories_index":"","tags_index":"Hexo,Github Pages","author_index":"Mins"}]