{"title":"Redis基础数据结构和命令","uid":"1c3e1155bc6ca82325e8a97f2309df25","slug":"Redis基础数据结构和命令","date":"2023-08-21T08:21:04.000Z","updated":"2023-08-24T02:37:40.764Z","comments":true,"path":"api/articles/Redis基础数据结构和命令.json","keywords":null,"cover":[],"content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>本篇文章将介绍Redis的基础数据结构和命令，熟练掌握了Redis的基础知识，才能更好的深入了解Redis的进阶底层原理</p></blockquote>\n<h3 id=\"一、Redis基础数据结构\"><a href=\"#一、Redis基础数据结构\" class=\"headerlink\" title=\"一、Redis基础数据结构\"></a>一、Redis基础数据结构</h3><p><em>Redis</em> 有 <em>5</em> 种基础数据结构，分别为：<em>string (字符串)、list (列表)、set (集合)、hash (哈 希) 和 zset (有序集合)</em></p>\n<h4 id=\"1-string-字符串\"><a href=\"#1-string-字符串\" class=\"headerlink\" title=\"1. string 字符串\"></a>1. string 字符串</h4><p>字符串 <em>string</em> 是 <em>Redis</em> 最简单的数据结构。Redis 所有的数据结构都是以唯一的 <em>key</em> 字符串作为名称，然后通过这个唯一 <em>key</em> 值来获取相应的 <em>value</em> 数据。不同类型的数据结构的差异就在于 <em>value</em> 的结构不一样</p>\n<p><img src=\"/post/Redis%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%91%BD%E4%BB%A4/string.png\" alt=\"string\"></p>\n<p>字符串结构使用非常广泛，一个常见的用途就是缓存用户信息。我们将用户信息结构体使用 <em>JSON</em> 序列化成字符串，然后将序列化后的字符串塞进 <em>Redis</em> 来缓存。同样，取用户信息会经过一次反序列化的过程。</p>\n<p><img src=\"/post/Redis%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%91%BD%E4%BB%A4/string%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86.png\" alt=\"string存储原理\"></p>\n<p><em>Redis</em> 的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于 <em>Java</em> 的 <em>ArrayList</em>，采用预分配冗余空间的方式来减少内存的频繁分配，如图中所示，内部为当前字符串实际分配的空间 <em>capacity</em> 一般要高于实际字符串长度 <em>len</em>。当字符串长度小于 <em>1M</em> 时，扩容都是加倍现有的空间，如果超过 <em>1M</em>，扩容时一次只会多扩 <em>1M</em> 的空间。需要注意的是字符串最大长度为 <em>512M</em>。</p>\n<h5 id=\"设置和读取键值对命令\"><a href=\"#设置和读取键值对命令\" class=\"headerlink\" title=\"设置和读取键值对命令\"></a>设置和读取键值对命令</h5><pre class=\"line-numbers language-redis\" data-language=\"redis\"><code class=\"language-redis\"># 添加单个 redis 键值对\nset [key] [value]\n\n# 获取单个 redis key 对应的值\nget [key]\n\n# 删除单个 redis 键值对\ndel [key]\n\n# 批量添加键值对\nmset [key1] [value1] [key2] [value2] [key3] [value3]\n\n# 批量获取 value\nmget [key1] [key2] [key3]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h5 id=\"过期和-set-命令拓展\"><a href=\"#过期和-set-命令拓展\" class=\"headerlink\" title=\"过期和 set 命令拓展\"></a>过期和 set 命令拓展</h5><p>可以对 <em>key</em> 设置过期时间，到点自动删除，这个功能常用来控制缓存的失效时间</p>\n<pre class=\"line-numbers language-redis\" data-language=\"redis\"><code class=\"language-redis\"># 设置键值对过期时间\nset [key] [value]\nexpire [key] [过期秒数]\n\n# 查看过期时间\nttl [key]\n\n# 设置键值对同时设置过期时间 等价于 set + expire\nsetex [key] [过期秒数] [value]\n\n# 如果 key 不存在，则新建，否则不处理，直接使用 set 会覆盖原值\nsetnx [key] [value]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h5 id=\"计数\"><a href=\"#计数\" class=\"headerlink\" title=\"计数\"></a>计数</h5><p>如果 <em>value</em> 值是一个整数，还可以对它进行自增操作。自增是有范围的，它的范围是 <em>signed long</em> 的最大最小值，超过了这个值，<em>Redis</em> 会报错</p>\n<pre class=\"line-numbers language-redis\" data-language=\"redis\"><code class=\"language-redis\"># 不指定增加长度则默认自增1\nset [key] 30\n\nincr [key]\n&gt; 31\n\n# 指定增加长度\nincrby [key] 5\n&gt; 36\n\nincrby [key] -5\n&gt; 31\n\n# Long.Max\nset [key] 9223372036854775807\nincrby [key] 5\n&gt; (error) ERR increment or decrement would overflow \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"2-list-列表\"><a href=\"#2-list-列表\" class=\"headerlink\" title=\"2. list 列表\"></a>2. list 列表</h4><p><em>Redis</em> 的列表相当于 <em>Java</em> 语言里面的 <em>LinkedList</em>，注意它是链表而不是数组。这意味着 <em>list</em> 的插入和删除操作非常快，时间复杂度为 *O(1)*，但是索引定位很慢，时间复杂度为 <em>O(n)</em></p>\n<p>当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收</p>\n<p><em>Redis</em> 的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进 <em>Redis</em> 的列表，另一个线程从这个列表中轮询数据进行处理</p>\n<pre class=\"line-numbers language-redis\" data-language=\"redis\"><code class=\"language-redis\"># 添加列表元素，其中push命令可以使用 lpush 和 rpush ，l代表在列表开头添加新元素，r代表在列表末尾添加新元素\nlpush list 1 2 3 4 5 6\n&gt; [6,5,4,3,2,1]\nrpush list 1 2 3 4 5 6\n&gt; [1,2,3,4,5,6]\n\n# 查询列表长度\nllen list\n&gt; (integer) 6\n\n# 弹出列表元素，和 push 类似，可以有 lpop 和 rpop ，组合使用达到不同的集合效果\nlist:[1,2,3,4,5,6]\n\nlpop list\n&gt; 1\nrpop list\n&gt; 6\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><em>lindex</em> 相当于 <em>Java</em> 链表的 <em>get(int index)</em> 方法，它需要对链表进行遍历，<strong>性能随着参数 index 增大而变差</strong>。 <em>ltrim</em> 和字面上的含义不太一样，个人觉得它叫 <em>lretain(保留)</em> 更合适一些，因为 <em>ltrim</em> 跟的两个参数 <em>start_index</em> 和 <em>end_index</em> 定义了一个区间，在这个区间内的值，<em>ltrim</em> 要保留，区间之外统统砍掉。我们可以通过 <em>ltrim</em> 来实现一个定长的链表，这一点非常有用。<em>index</em> 可以为负数，<em>index=-1</em> 表示倒数第一个元素，同样 <em>index=-2</em> 表示倒数第二个元素。</p>\n<pre class=\"line-numbers language-redis\" data-language=\"redis\"><code class=\"language-redis\"># lindex 根据索引获取值\nlist:[1,2,3,4,5,6]\n\nlindex list 1\n&gt; (integer) 2\n\n# ltrim 只保留区间索引的值\nltrim list 1 -1 \n&gt; list:[2,3,4,5,6] \n\n# lrange 输出区间索引的值\nlrange list 3 -1\n&gt; list: [4,5,6]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h5 id=\"快速列表\"><a href=\"#快速列表\" class=\"headerlink\" title=\"快速列表\"></a>快速列表</h5><p><img src=\"/post/Redis%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%91%BD%E4%BB%A4/quicklist.png\" alt=\"quicklist\"></p>\n<p>如果再深入一点，你会发现 <em>Redis</em> 底层存储的还不是一个简单的 <em>linkedlist</em>，而是称之为快速链表 <em>quicklist</em> 的一个结构。首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 <em>ziplist</em>，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成 quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间，而且会加重内存的碎片化。比如这个列表里存的只是 <em>int</em> 类型的数据，结构上还需要两个额外指针 <em>prev</em> 和 <em>next</em> 。所以 Redis 将链表和 <em>ziplist</em> 结合起来组成了 <em>quicklist</em>。也就是将多个 <em>ziplist</em> 使用双向指针串起来使用。这样既满足了快的插入删除性能，又不会出现太大的空间冗余。</p>\n<h4 id=\"3-hash字典\"><a href=\"#3-hash字典\" class=\"headerlink\" title=\"3. hash字典\"></a>3. hash字典</h4><p><em>Redis</em> 的字典相当于 <em>Java</em> 语言里面的 <em>HashMap</em>，它是无序字典。内部实现结构上同 <em>Java</em> 的 <em>HashMap</em> 也是一致的，同样的数组 + 链表二维结构。第一维 <em>hash</em> 的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。</p>\n<p><img src=\"/post/Redis%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%91%BD%E4%BB%A4/hashmap.png\" alt=\"hashmap\"></p>\n<p>不同的是，<em>Redis</em> 的字典的值只能是字符串，另外它们 <em>rehash</em> 的方式不一样，因为 <em>Java</em> 的 <em>HashMap</em> 在字典很大时，<em>rehash</em> 是个耗时的操作，需要一次性全部 <em>rehash</em>。<em>Redis</em> 为了高性能，不能堵塞服务，所以采用了渐进式 <em>rehash</em> 策略。</p>\n<p><img src=\"/post/Redis%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%91%BD%E4%BB%A4/rehash.png\" alt=\"rehash\"></p>\n<p>渐进式 <em>rehash</em> 会在 <em>rehash</em> 的同时，保留新旧两个 <em>hash</em> 结构，查询时会同时查询两个 <em>hash</em> 结构，然后在后续的定时任务中以及 <em>hash</em> 的子指令中，循序渐进地将旧 <em>hash</em> 的内容一点点迁移到新的 <em>hash</em> 结构中。</p>\n<ul>\n<li>当 <em>hash</em> 移除了最后一个元素之后，该数据结构自动被删除，内存被回收。<em>hash</em> 结构也可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象，<em>hash</em> 可以对用户结构中的每个字段单独存储。这样当我们需要获取用户信息时可以进行部分获取。而以整个字符串的形式去保存用户信息的话就只能一次性全部读取，这样就会比较浪费网络流量。</li>\n<li><em>hash</em> 也有缺点，<em>hash</em> 结构的存储消耗要高于单个字符串，到底该使用 <em>hash</em> 还是字符串，需要根据实际情况再三权衡。</li>\n</ul>\n<pre class=\"line-numbers language-redis\" data-language=\"redis\"><code class=\"language-redis\"># 创建 hash 表\nhset hashmap [key] [value]\n\n# 获取 hash 表的值\nhget hashmap [key]\n\n# 批量创建 hash 表键值对\nhmset hashmap [key1] [value1] [key2] [value2] [key2] [value2]\n\n# 批量获取 hash 表键值对\nhmget hashmap [key1] [key2] [key3]\n\n# 获取 hash 表的所有key\nhkeys hashmap\n\n# 获取 hash 表所有键值对，key 和 value 依次输出\nhgetall hashmap\n\n# 获取 hash 表的键值对长度\nhlen hashmap\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>同字符串一样，<em>hash</em> 结构中的单个子 <em>key</em> 也可以进行计数，它对应的指令是 <em>hincrby</em>， 和 <em>incr</em> 使用基本一样</p>\n<pre class=\"line-numbers language-redis\" data-language=\"redis\"><code class=\"language-redis\"># 给 hash 表中数字的值做增减\nage : 18\n\nhincrby hashmap age 5\n&gt; (integer) 23<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"4-set-集合\"><a href=\"#4-set-集合\" class=\"headerlink\" title=\"4. set 集合\"></a>4. set 集合</h4><p><em>Redis</em> 的集合相当于 <em>Java</em> 语言里面的 <em>HashSet</em>，它内部的键值对是无序的唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 <em>value</em> 都是一个值 <em>NULL</em>。当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。 <em>set</em> 结构可以用来存储活动中奖的用户 <em>ID</em>，因为有去重功能，可以保证同一个用户不会中奖两次。</p>\n<pre class=\"line-numbers language-redis\" data-language=\"redis\"><code class=\"language-redis\"># 添加元素\nsadd hashset &lt;value&gt;\n&gt; (integer) 1\n# 添加重复元素\nsadd hashset &lt;value&gt;\n&gt; (integer) 0\n# 批量添加元素和单个是一样的命令\nsadd hashset &lt;value1&gt; &lt;value2&gt; &lt;value3&gt;...\n\n# 查询 set 的所有值 该集合是无序的\nsmembers hashset\n\n# 判断 set 中是否存在该值\nsismember hashset &lt;value&gt;\n&gt; (integer) 1\n\n# 获取 set 长度\nscard hashset\n&gt; (integer) 1\n\n# 取出一个元素 （无序）\nspop hashset\n&gt; &lt;value&gt;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"5-有序列表-zset\"><a href=\"#5-有序列表-zset\" class=\"headerlink\" title=\"5. 有序列表 zset\"></a>5. 有序列表 zset</h4><p><em>zset</em> 可能是 <em>Redis</em> 提供的最为特色的数据结构，它也是在面试中面试官最爱问的数据结构。它类似于 <em>Java</em> 的 <em>SortedSet</em> 和 <em>HashMap</em> 的结合体，一方面它是一个 <em>set</em>，保证了内部 <em>value</em> 的唯一性，另一方面它可以给每个 <em>value</em> 赋予一个 <em>score</em>，代表这个 <em>value</em> 的排序权重。它的内部实现用的是一种叫着<em>「跳跃列表」</em>的数据结构。<em>zset</em> 中最后一个 <em>value</em> 被移除后，数据结构自动删除，内存被回收。 <em>zset</em> 可以用来存粉丝列表，<em>value</em> 值是粉丝的<em>用户 <em>ID，</em>score</em> 是关注时间。我们可以对粉丝列表按关注时间进行排序。<em>zset</em> 还可以用来存储学生的成绩，<em>value</em> 值是<em>学生的 ID</em>，<em>score</em> 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次。</p>\n<pre class=\"line-numbers language-redis\" data-language=\"redis\"><code class=\"language-redis\"># 添加有序列表元素\nzadd sortmap &lt;score&gt; &lt;value&gt;\nzadd sortmap 8.1 &quot;I love Java&quot;\nzadd sortmap 7.1 &quot;I love Python&quot;\nzadd sortmap 6.1 &quot;I love Php&quot;\n\n# 列出索引区间的元素,按 score 升序列出，参数区间为排名范围\nzrange sortmap 0 -1  \n&gt; &quot;I love Php&quot;\n&gt; &quot;I love Python&quot;\n&gt; &quot;I love Java&quot;\n\n# 逆序列出索引区间的元素,按 score 降序列出，参数区间为排名范围\nzrevrange sortmap 0 -1\n&gt; &quot;I love Java&quot;\n&gt; &quot;I love Python&quot;\n&gt; &quot;I love Php&quot;\n\n# 输出集合长度\nzcard sortmap\n&gt; (integet) 3\n\n# 获取指定 value 值的 score\nzscore &quot;I love Python&quot;\n&gt; 7.0999999999999996  # double 会有精度问题\n\n# 根据 score 区间分值获取元素\nzrangebyscore sortmap 0 8\n&gt; &quot;I love Python&quot;   \n&gt; &quot;I love Php&quot;\n\n# 删除 value\nzrem sortmap &quot;I love Java&quot;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"跳跃列表\"><a href=\"#跳跃列表\" class=\"headerlink\" title=\"跳跃列表\"></a>跳跃列表</h5><p><em>zset</em> 内部的排序功能是通过<em>「跳跃列表」</em>数据结构来实现的，它的结构非常特殊，也比较复杂。因为 <em>zset</em> 要支持随机的插入和删除，所以它不好使用数组来表示。我们先看一个普通的链表结构。</p>\n<p><img src=\"/post/Redis%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%91%BD%E4%BB%A4/jumplist.png\" alt=\"jumplist\"></p>\n<p>我们需要这个链表按照 score 值进行排序。这意味着当有新元素需要插入时，要定位到特定位置的插入点，这样才可以继续保证链表是有序的。通常我们会通过二分查找来找到插入点，但是二分查找的对象必须是数组，只有数组才可以支持快速位置定位，链表做不到，那该怎么办？</p>\n<p>想想一个创业公司，刚开始只有几个人，团队成员之间人人平等，都是联合创始人。随着公司的成长，人数渐渐变多，团队沟通成本随之增加。这时候就会引入组长制，对团队进行划分。每个团队会有一个组长。开会的时候分团队进行，多个组长之间还会有自己的会议安排。公司规模进一步扩展，需要再增加一个层级 —— 部门，每个部门会从组长列表中推选出一个代表来作为部长。部长们之间还会有自己的高层会议安排。跳跃列表就是类似于这种层级制，最下面一层所有的元素都会串起来。然后每隔几个元素挑选出一个代表来，再将这几个代表使用另外一级指针串起来。然后在这些代表里再挑出二级代表，再串起来。最终就形成了金字塔结构。 想想你老家在世界地图中的位置：亚洲- -&gt;中国-&gt;安徽省-&gt;安庆市-&gt;枞阳县-&gt;汤沟镇-&gt;田间村-&gt;xxxx 号，也是这样一个类似的结构。</p>\n<p><img src=\"/post/Redis%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%91%BD%E4%BB%A4/jumplist2.png\" alt=\"jumplist\"></p>\n<p><em>「跳跃列表」</em>之所以<em>「跳跃」</em>，是因为内部的元素可能<em>「身兼数职」</em>，比如上图中间的这个元素，同时处于 L0、L1 和 L2 层，可以快速在不同层次之间进行<em>「跳跃」</em>。定位插入点时，先在顶层进行定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插进去。你也许会问，那新插入的元素如何才有机会<em>「身兼数职」</em>呢？跳跃列表采取一个随机策略来决定新元素可以兼职到第几层。首先 L0 层肯定是 <em>100%</em> 了，L1 层只有 <em>50%</em> 的概率，L2 层只有 <em>25%</em> 的概率，L3 层只有 <em>12.5%</em> 的概率，一直随机到最顶层 L31 层。绝大多数元素都过不了几层，只有极少数元素可以深入到顶层。列表中的元素越多，能够深入的层次就越深，能进入到顶层的概率就会越大。</p>\n<h3 id=\"二、-容器型数据结构的通用规则\"><a href=\"#二、-容器型数据结构的通用规则\" class=\"headerlink\" title=\"二、 容器型数据结构的通用规则\"></a>二、 容器型数据结构的通用规则</h3><p><strong>list/set/hash/zset 这四种数据结构是容器型数据结构，它们共享下面两条通用规则：</strong></p>\n<h4 id=\"1、create-if-not-exists\"><a href=\"#1、create-if-not-exists\" class=\"headerlink\" title=\"1、create if not exists\"></a>1、create if not exists</h4><p>如果容器不存在，那就创建一个，再进行操作。比如 <em>rpush</em> 操作刚开始是没有列表的，<em>Redis</em> 就会自动创建一个，然后再 <em>rpush</em> 进去新元素。</p>\n<h4 id=\"2、drop-if-no-elements\"><a href=\"#2、drop-if-no-elements\" class=\"headerlink\" title=\"2、drop if no elements\"></a>2、drop if no elements</h4><p>如果容器里元素没有了，那么立即删除元素，释放内存。这意味着 <em>lpop</em> 操作到最后一个元素，列表就消失了。过期时间 <em>Redis</em> 所有的数据结构都可以设置过期时间，时间到了，<em>Redis</em> 会自动删除相应的对象。需要注意的是过期是以对象为单位，比如一个 <em>hash</em> 结构的过期是整个 <em>hash</em> 对象的过期，而不是其中的某个子 <em>key</em>。还有一个需要特别注意的地方是如果一个字符串已经设置了过期时间，然后你调用了 <em>set</em> 方法修改了它，它的过期时间会消失。</p>\n<pre class=\"line-numbers language-redis\" data-language=\"redis\"><code class=\"language-redis\">set codehole yoyo \n&gt; OK \nexpire codehole 600 \n&gt; (integer) 1 \nttl codehole \n&gt; (integer) 597 \nset codehole yoyo \n&gt; OK \nttl codehole \n&gt; (integer) -1\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>部分内容摘录自<strong>《Redis深度历险：核心原理和应用实践》</strong>这本书，有兴趣的朋友可以阅读这本书了解更多关于 Redis 的知识</p></blockquote>\n","feature":true,"text":" 本篇文章将介绍Redis的基础数据结构和命令，熟练掌握了Redis的基础知识，才能更好的深入了解Redis的进阶底层原理 一、Redis基础数据结构Redis 有 5 种基础数据结构，分别为：string (字符串)、list (列表)、set (集合)、hash (哈 希) ...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Redis","slug":"Redis","count":1,"path":"api/tags/Redis.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81Redis%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">一、Redis基础数据结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-string-%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">1. string 字符串</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%AF%BB%E5%8F%96%E9%94%AE%E5%80%BC%E5%AF%B9%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">设置和读取键值对命令</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%BF%87%E6%9C%9F%E5%92%8C-set-%E5%91%BD%E4%BB%A4%E6%8B%93%E5%B1%95\"><span class=\"toc-text\">过期和 set 命令拓展</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E6%95%B0\"><span class=\"toc-text\">计数</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-list-%E5%88%97%E8%A1%A8\"><span class=\"toc-text\">2. list 列表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E5%88%97%E8%A1%A8\"><span class=\"toc-text\">快速列表</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-hash%E5%AD%97%E5%85%B8\"><span class=\"toc-text\">3. hash字典</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-set-%E9%9B%86%E5%90%88\"><span class=\"toc-text\">4. set 集合</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8-zset\"><span class=\"toc-text\">5. 有序列表 zset</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8\"><span class=\"toc-text\">跳跃列表</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81-%E5%AE%B9%E5%99%A8%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%84%E5%88%99\"><span class=\"toc-text\">二、 容器型数据结构的通用规则</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81create-if-not-exists\"><span class=\"toc-text\">1、create if not exists</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81drop-if-no-elements\"><span class=\"toc-text\">2、drop if no elements</span></a></li></ol></li></ol>","author":{"name":"Mins","slug":"blog-author","avatar":"/image/avatar.jpeg","link":"https://zmstrongest.github.io","description":"Think like an artist, code like an artisan.","socials":{"github":"https://zmstrongest.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"Java位运算","uid":"924e7fa1333bf7d72633305ec8d70397","slug":"Java位运算","date":"2022-09-20T04:21:50.000Z","updated":"2022-10-12T09:50:07.956Z","comments":true,"path":"api/articles/Java位运算.json","keywords":null,"cover":[],"text":" 在刷 leetcode 题目的时候，有部分题目的解题方法都用到了位运算来解决二进制或者部分数学题目，能够减少部分题目的运行时间，但因为平时用的比较少，也没有深入了解过，本篇文章将记录 Java 位运算的知识点，同时不断更新位运算的运用场景，用好位运算在某些场景能够减少许多逻辑计...","link":"","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":1,"path":"api/tags/Java.json"},{"name":"位运算","slug":"位运算","count":1,"path":"api/tags/位运算.json"},{"name":"二进制","slug":"二进制","count":1,"path":"api/tags/二进制.json"}],"author":{"name":"Mins","slug":"blog-author","avatar":"/image/avatar.jpeg","link":"https://zmstrongest.github.io","description":"Think like an artist, code like an artisan.","socials":{"github":"https://zmstrongest.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}